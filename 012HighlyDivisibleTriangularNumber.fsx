(*
    The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
*)

#load "000Common.fsx"
open Common.Utils

(*
    Let divisors of a number are [2;2;2;3]
    Then:
    2 can be seen between 0 and 3 times -> 4 times
    3 can be seen between 0 and 1 times -> 2 times

    the number of possible divisors is 4 * 2
    See: https://math.stackexchange.com/questions/1638531/number-of-positive-integral-divisors
*)


let getTriangular n = (n * (n+1L)) / 2L 

let product = Seq.reduce (*)

let getUniqueElemsGroupsLengths l = l |> List.groupBy id |> List.map (snd >> List.length) 

let possibleDivisorsCount l = l |> List.map ((+) 1) |> product

let smallestTriangularWithDivisorsCount primeFactorization minimumDivisorsCount= 
    let rec smallestTriangular n = 
        let possibleFactors = 2L::[3L..2L..int64(sqrt(float n))]
        let currentTriangular = getTriangular n        
        let uniqueElemsGroupsLengths = 
            currentTriangular |> (primeFactorization possibleFactors) |> getUniqueElemsGroupsLengths             
        let divisorsCount = possibleDivisorsCount uniqueElemsGroupsLengths
        if divisorsCount >= minimumDivisorsCount 
        then currentTriangular
        else smallestTriangular (n+1L)

    smallestTriangular 2L 

// ---------------------------------------
(*
    Solution 2
    Some optimizations:    
    Optimization 1:
    A number that obviously has more than 500 divisors is the product of the first 9 primes - N
    But this number is bigger than 2 * 2 * 3 * 3 *...* 19 which also has more thab 500 combinations - 
    [2;2;3;3;5;7;11;13;17;19] |> getUniqueElemsGroupsLengths |> possibleDivisorsCount
    
    So, the search number is a product of the first 9 primes, 
*)
let ninthPrime = 23
let primes = getSmallerPrimes (ninthPrime + 1) |> Seq.map int64 |> List.ofSeq

let smallestTriangularWithDivisorsCount2 primeFactorization possibleFactors minimumDivisorsCount = 
    let rec smallestTriangular n =         
        let currentTriangular = getTriangular n        
        let uniqueElemsGroupsLengths = 
            currentTriangular |> (primeFactorization possibleFactors) |> getUniqueElemsGroupsLengths             
        let divisorsCount = possibleDivisorsCount uniqueElemsGroupsLengths
        if divisorsCount >= minimumDivisorsCount 
        then currentTriangular
        else smallestTriangular (n+1L)

    smallestTriangular 2L 

// #time
smallestTriangularWithDivisorsCount primeFactorization 500
smallestTriangularWithDivisorsCount2 primeFactorization primes 500

